#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# vim: set sw=4 expandtab:
#
# Created: 2019-08-06
# Main authors:
#     - Marc Dorval <marc.dorval@silabs.com>
#
# Copyright (c) 2019, Silicon Laboratories
# See license terms contained in COPYING file
#

# Generate PTA bytes from input parameters
#

from __future__ import print_function

# If you modify this file, please don't forget to increment version number.
__version__ = "0.2.5"

import sys
import argparse


class PtaSettings(object):
    def __init__(self):
        super().__init__()
        self.pta_cmd = None

class WfxPtaData(object):

    settings_parameters = [
        #  Parameter, type, bytes, choices, default, help
        ('config'                      , str, 1, ['1w_wlan_master_example', '1w_coex_master_example', '2w_example', '3w_example', '4w_example'], None, """
              Preset configurations for common use cases examples
                  (These presets can be used as start points
                  and be overwritten using options listed below to fine-tune specific options)"""),
        ('pta_mode'                    , str, 1, {'1w_wlan_master': 0, '1w_coex_master': 1, '2w': 2, '3w': 3, '4w': 4}, '1w_wlan_master', """
            PTA mode selection"""),
        ('request_signal_active_level' , str, 1, {'low': 0, 'high':  1}, 'low', """
            (input) Active level on REQUEST signal, provided by Coex to request the RF"""),
        ('priority_signal_active_level', str, 1, {'low': 0, 'high':  1}, 'low', """
            (input) Active level on PRIORITY signal, provided by Coex to set the priority of the request"""),
        ('freq_signal_active_level'    , str, 1, {'low': 0, 'high':  1}, 'low', """
            (input) Active level on FREQ signal, provided by Coex in 4-wire mode 
              when Coex and Wlan share the same band"""),
        ('grant_signal_active_level'   , str, 1, {'low': 0, 'high':  1}, 'low', """
           (output) Active level on grant signal, generated by PTA 
             to grant the RF to Coex"""),
        ('coex_type'                   , str, 1, {'generic': 0, 'ble': 1}, 'generic', """
            Coex type"""),
        ('default_grant_state'         , str, 1, {'no_grant': 0, 'grant': 1}, 'no_grant', """
          State of the grant signal before arbitration at grant_valid_time"""),
        ('simultaneous_rx_accesses'    , str, 1, {'false': 0, 'true': 1}, 'false', """
          (uint8),  Boolean to allow both Coex and Wlan to receive concurrently, 
            also named combined mode"""),
        ('priority_sampling_time'      , int, 1, None, 0, """
          (uint8),  Time in microseconds from the Coex request to the sampling of the
            priority on PRIORITY signal (1 to 31),"""),
        ('tx_rx_sampling_time'         , int, 1, None, 0, """
          (uint8),  Time in microseconds from the Coex request to the 
            sampling of the directionality on PRIORITY signal (priority_sampling_time to 63)"""),
        ('freq_sampling_time'          , int, 1, None, 0, """
          (uint8),  Time in microseconds from the Coex request to the
            sampling of the freq-match information on FREQ signal (1 to 127)"""),
        ('grant_valid_time'            , int, 1, None, 0, """
          (uint8),  Time in microseconds from Coex request to the 
            grant signal assertion (max(tx_rx_sampling_time, freq_sampling_time), to 0xFF),"""),
        ('fem_control_time'            , int, 1, None, 0, """
          (uint8),  Time in microseconds from Coex request to the 
            control of FEM (grant_valid_time to 0xFF),"""),
        ('first_slot_time'             , int, 1, None, 0, """
          (uint8),  Time in microseconds from the Coex request to the 
            beginning of reception or transmission (grant_valid_time to 0xFF),"""),
        ('periodic_tx_rx_sampling_time', int, 2, None, 0, """
          (uint16), Period in microseconds from first_slot_time of following samplings of the 
              directionality on PRIORITY signal (1 to 1023),"""),
        ('coex_quota'                  , int, 2, None, 0, """
          (uint16), Duration in microseconds for which RF is granted to Coex 
              before it is moved to Wlan"""),
        ('wlan_quota'                  , int, 2, None, 0, """
          (uint16), Duration in microseconds for which RF is granted to Wlan 
              before it is moved to Coex""")
    ]

    priority_parameters = [
        #  Parameter, type, bytes,  choices, default, help
        ('priority_mode'      , str, 4, {'coex_maximized': 0x00000562, 'coex_high':0x00000462, 'balanced':0x00001461, 'wlan_high':0x00001851, 'wlan_maximized': 0x00001A51}, None, """
            coex_maximized = 0x00000562 : Maximizes priority to COEX, WLAN connection is not ensured.  
            coex_high      = 0x00000462 : High priority to COEX, targets low-latency to COEX. 
            balanced       = 0x00001461 : Balanced PTA arbitration, WLAN acknowledge receptions are protected. 
            wlan_high      = 0x00001851 : High priority to WLAN, protects WLAN transmissions. 
            wlan_maximized = 0x00001A51 : Maximizes priority to WLAN"""),
        ('coex_prio_low'      , int, 0.3, None, 0, """Priority given to Coex for low-priority requests"""),
        ('reserved1'          , int, 0.1, None, 0, """Reserved for future use"""),
        ('coex_prio_high'     , int, 0.3, None, 0, """Priority given to Coex for high-priority requests"""),
        ('reserved2'          , int, 0.1, None, 0, """Reserved for future use"""),
        ('grant_coex'         , int, 0.1, None, 0, """Allows Coex to override Wlan"""),
        ('grant_wlan'         , int, 0.1, None, 0, """Allows Wlan to override Coex whenever Wlan is not idle"""),
        ('protect_coex'       , int, 0.1, None, 0, """Wlan grant is delayed until Coex has finished its present granted transaction"""),
        ('protect_wlan_tx'    , int, 0.1, None, 0, """Prevents Coex from being granted when Wlan is transmitting (the protection is also extended to the response)"""),
        ('protect_wlan_rx'    , int, 0.1, None, 0, """Prevents Coex from being granted when Wlan is receiving or waiting for a response to an already transmitted frame"""),
        ('reserved3'          , int, 2.3, None, 0, """Reserved for future use""")
    ]

    state_parameters = [
        #  Parameter, type, bytes,  choices, default, help
        ('state', str, 4, {'off': 0, 'on': 1}, 'off', """
            PTA state on/off""")
    ]

    def __init__(self, mode=None, **kwargs):
        self.g_settings = PtaSettings
        self.g_settings.pta_cmd = None
        self.sysargs = sys.argv[1:]
        self.mode = mode if mode else 'quiet'

    def set_args(self, args=None):
        """set_args() is used to provide the settings as a string (space separator)
            as it would be done through command-line arguments"""
        if args is not None:
            self.sysargs = args.split(' ')
        else:
            self.sysargs = []

    def print_if_verbose(self, txt, end=None):
        if self.mode == 'verbose':
            print(txt, end=end)

    def data(self):
        self.print_if_verbose(self.sysargs)
        self.g_settings = PtaSettings
        self.g_settings.pta_cmd = None
        user_options = self.parse_cmdline(self, self.sysargs)
        # self.print_if_verbose(user_options)
        self.apply_options(self, user_options, self.sysargs)
        return self.pta_bytes()

    @staticmethod
    def parse_cmdline(self, args):
        parser = argparse.ArgumentParser(
                                        formatter_class=argparse.RawDescriptionHelpFormatter,
                                        description="""
        Prepare and send PTA parameters depending on the selected pta_cmd
        """,
                                        epilog="""
        Examples:

        Python3 interpreter:
        python3
         >>> from wfx_pta import *
        selecting the connection mode to match your DUT:
         >>> dut = WfxPtaTarget('Pi203', host='pi203', user='pi', port=22, password='default_password')
         >>> dut = WfxPtaTarget('Serial', port='COM8')
         >>> dut = WfxPtaTarget('Local')
         selecting settings, priority and activating PTA:
         >>> dut.settings('--config 3w_ble --first_slot_time 123')
         >>> dut.priority('--priority_mode balanced')
         >>> dut.state('--state on')
         activating PTA traces (tracks PTA data values):
         >>> dut.trace = True
         activating communication link traces (tracks bytes write/read):
         >>> dut.link.trace = True
         
        Command line using 'wfx_pta.py': directly sending PTA bytes to a 'Local' DUT: 
         (bytes silently sent to DUT)
           python wfx_pta.py settings --config 3w_example
           python wfx_pta.py priority --priority_mode balanced
           python wfx_pta.py state --state on
         (verbose mode)
           python wfx_pta.py settings --config 3w_example verbose
            Local: configuring a Direct connection
            ['settings', '--config', '3w_example']
            configuring for 3w_example
            pta_mode                       1w_wlan_master =>       3w
            request_signal_active_level         low =>     high
            priority_signal_active_level        low =>     high
            default_grant_state            no_grant =>    grant
            priority_sampling_time                0 =>       10
            grant_valid_time                      0 =>       72
            fem_control_time                      0 =>      140
            pta_mode                       3w         \x03
            request_signal_active_level    high       \x01
            priority_signal_active_level   high       \x01
            freq_signal_active_level       low        \x00
            grant_signal_active_level      low        \x00
            coex_type                      generic    \x00
            default_grant_state            grant      \x01
            simultaneous_rx_accesses       false      \x00
            priority_sampling_time         10         \x0a
            tx_rx_sampling_time            0          \x00
            freq_sampling_time             0          \x00
            grant_valid_time               72         \x48
            fem_control_time               140        \x8c
            first_slot_time                0          \x00
            periodic_tx_rx_sampling_time   0          \x00\x00
            coex_quota                     0          \x00\x00
            wlan_quota                     0          \x00\x00
            Local    D>>|  wfx_exec wfx_hif_send_msg "\\x18\\x00\\x2b\\x00\\x03\\x01\\x01\\x00\\x00\\x00\\x01\\x00\\x0a\\x00\\x00\\x48\\x8c\\x00\\x00\\x00\\x00\\x00\\x00\\x00"
            Local    D<<|  0

        Command line using 'wfx_pta_data.py': retrieving the PTA bytes (no byte sent to HW):
          python wfx_pta_data.py settings --config 3w_example
            \\x18\\x00\\x2b\\x00\\x03\\x01\\x01\\x00\\x00\\x00\\x01\\x00\\x0a\\x00\\x00\\x48\\x8c\\x00\\x00\\x00\\x00\\x00\\x00\\x00
          python wfx_pta_data.py settings --config 3w_example --grant_valid_time 40 --priority_sampling_time 8
            \\x18\\x00\\x2b\\x00\\x03\\x01\\x01\\x00\\x00\\x00\\x01\\x00\\x08\\x00\\x00\\x28\\x8c\\x00\\x00\\x00\\x00\\x00\\x00\\x00
          python wfx_pta_data.py priority --priority_mode balanced
            \x04\x00\x2c\x00\x61\x14\x00\x00
          python wfx_pta_data.py priority --coex_prio_low 1 --coex_prio_high 5 --grant_wlan 1 --protect_wlan_tx 1 --protect_wlan_rx 1
            \x04\x00\x2c\x00\x51\x1a\x00\x00
          python wfx_pta_data.py state --state on
            \\x08\\x00\\x2d\\x00\\x01\\x00\\x00\\x00
          python wfx_pta_data.py state --state off
            \\x08\\x00\\x2d\\x00\\x00\\x00\\x00\\x00
        
        """)
        parser.add_argument("pta_cmd", choices=['settings', 'priority', 'state'],
                            help="pta_cmd <settings/priority/state>")
        parser.add_argument('--version', action='version',
                            version='%(prog)s {version}'.format(version=__version__))

        parser_settings = parser.add_argument_group('settings')
        for item in self.settings_parameters:
            _name, _type, _bytes, _choices, _default, _help = item
            if _default is None:
                parser_settings.add_argument('--' + _name, type=_type, default=_default, choices=_choices, help=_help)
            else:
                parser_settings.add_argument('--' + _name, type=_type, default=_default, choices=_choices, help=_help +
                                             ' (default ' + str(_default) + ')')

        parser_priority = parser.add_argument_group('priority')
        for item in self.priority_parameters:
            _name, _type, _bytes, _choices, _default, _help = item
            if _default is None:
                parser_priority.add_argument('--' + _name, type=_type, default=_default, choices=_choices, help=_help)
            else:
                parser_priority.add_argument('--' + _name, type=_type, default=_default, choices=_choices, help=_help +
                                             ' (default ' + str(_default) + ')')

        parser_state = parser.add_argument_group('state')
        for item in self.state_parameters:
            _name, _type, _bytes, _choices, _default, _help = item
            parser_state.add_argument('--' + _name, type=_type, default=_default, choices=_choices, help=_help)

        return parser.parse_args(args)

    @staticmethod
    def settings_by_config(self, config):
        if config == '1w_wlan_master_example':
            self.print_if_verbose('configuring for %s' % config)
            self.g_settings.pta_mode = '1w_wlan_master'
            # 1 wire SIGNAL (GRANT: out)
            self.g_settings.grant_signal_active_level = 'low'
            self.g_settings.default_grant_state = 'grant'
            # coex/wlan quotas
            self.g_settings.coex_quota = 7500
            self.g_settings.wlan_quota = 7500

        if config == '1w_coex_master_example':
            self.print_if_verbose('configuring for %s' % config)
            self.g_settings.pta_mode = '1w_coex_master'
            # 1 wire SIGNAL (REQUEST: in)
            self.g_settings.request_signal_active_level = 'high'

        if config == '2w_example':
            self.print_if_verbose('configuring for %s' % config)
            self.g_settings.pta_mode = '2w'
            # 2 wire SIGNALS (GRANT: out, REQUEST: in)
            self.g_settings.grant_signal_active_level = 'low'
            self.g_settings.default_grant_state = 'grant'
            self.g_settings.request_signal_active_level = 'high'

        if config == '3w_example':
            self.print_if_verbose('configuring for %s' % config)
            self.g_settings.pta_mode = '3w'
            # 3 wire SIGNALS (GRANT: out, REQUEST: in, PRIORITY: in)
            self.g_settings.grant_signal_active_level = 'low'
            self.g_settings.default_grant_state = 'grant'
            self.g_settings.request_signal_active_level = 'high'
            self.g_settings.priority_signal_active_level = 'high'
            # Coex control
            self.g_settings.coex_type = 'generic'
            self.g_settings.simultaneous_rx_accesses = 'false'
            # Timings (BLE example)
            #  PRIORITY signal: priority_sampling_time < grant_valid_time < fem_control_time
            self.g_settings.priority_sampling_time = 10
            self.g_settings.grant_valid_time = 72
            self.g_settings.fem_control_time = 140

        if config == '4w_example':
            self.print_if_verbose('configuring for %s' % config)
            self.g_settings.pta_mode = '4w'
            # 4 wire SIGNALS (GRANT: out, REQUEST: in, PRIORITY: in, FREQ: in)
            self.g_settings.grant_signal_active_level = 'low'
            self.g_settings.default_grant_state = 'grant'
            self.g_settings.request_signal_active_level = 'high'
            self.g_settings.priority_signal_active_level = 'high'
            self.g_settings.freq_signal_active_level = 'high'
            # Coex control
            self.g_settings.coex_type = 'generic'
            self.g_settings.simultaneous_rx_accesses = 'true'
            # Timings (ZIGBEE example)
            #  PRIORITY signal: priority_sampling_time < tx_rx_sampling_time < grant_valid_time <= first_slot_time
            #  FREQ     signal:                           freq_sampling_time < grant_valid_time < fem_control_time
            self.g_settings.priority_sampling_time = 10
            self.g_settings.tx_rx_sampling_time = 30
            self.g_settings.freq_sampling_time = 30
            self.g_settings.grant_valid_time = 40
            self.g_settings.fem_control_time = 40
            self.g_settings.first_slot_time = 40

            self.g_settings.periodic_tx_rx_sampling_time = 10

    @staticmethod
    def priorities_by_mode(self, priority_mode):
       #'priority_mode'  'coex_maximized': 0x00000562
        if priority_mode == 'coex_maximized':
            self.print_if_verbose('configuring for %s' % priority_mode)
            self.g_settings.coex_prio_low  = 2
            self.g_settings.coex_prio_high = 6
            self.g_settings.grant_coex = 1
            self.g_settings.grant_wlan = 0
            self.g_settings.protect_coex = 1
            self.g_settings.protect_wlan_tx = 0
            self.g_settings.protect_wlan_rx = 0

       #'priority_mode'  'coex_high':0x00000462
        if priority_mode == 'coex_high':
            self.print_if_verbose('configuring for %s' % priority_mode)
            self.g_settings.coex_prio_low  = 2
            self.g_settings.coex_prio_high = 6
            self.g_settings.grant_coex = 0
            self.g_settings.grant_wlan = 0
            self.g_settings.protect_coex = 1
            self.g_settings.protect_wlan_tx = 0
            self.g_settings.protect_wlan_rx = 0

       #'priority_mode'  'balanced':0x00001461
        if priority_mode == 'balanced':
            self.print_if_verbose('configuring for %s' % priority_mode)
            self.g_settings.coex_prio_low  = 1
            self.g_settings.coex_prio_high = 6
            self.g_settings.grant_coex = 0
            self.g_settings.grant_wlan = 0
            self.g_settings.protect_coex = 1
            self.g_settings.protect_wlan_tx = 0
            self.g_settings.protect_wlan_rx = 1

       #'priority_mode'  'wlan_high':0x00001851
        if priority_mode == 'wlan_high':
            self.print_if_verbose('configuring for %s' % priority_mode)
            self.g_settings.coex_prio_low  = 1
            self.g_settings.coex_prio_high = 5
            self.g_settings.grant_coex = 0
            self.g_settings.grant_wlan = 0
            self.g_settings.protect_coex = 0
            self.g_settings.protect_wlan_tx = 1
            self.g_settings.protect_wlan_rx = 1

       #'priority_mode'  'wlan_maximized': 0x00001a51
        if priority_mode == 'wlan_maximized':
            self.print_if_verbose('configuring for %s' % priority_mode)
            self.g_settings.coex_prio_low  = 1
            self.g_settings.coex_prio_high = 5
            self.g_settings.grant_coex = 0
            self.g_settings.grant_wlan = 1
            self.g_settings.protect_coex = 0
            self.g_settings.protect_wlan_tx = 1
            self.g_settings.protect_wlan_rx = 1

    @staticmethod
    def apply_options(self, options, user_args):
        if not options.pta_cmd:
            print('No pta_cmd! Use settings, priority or state')
        # filling defaults and self.g_settings with default values
        defaults = self.parse_cmdline(self, args=[options.pta_cmd])
        self.g_settings = self.parse_cmdline(self, args=[options.pta_cmd])
        self.print_if_verbose('\n+++++ options:' + str(options) + "\n")
        self.g_settings.pta_cmd = options.pta_cmd

        if options.pta_cmd == 'settings':
            if options.config is not None:
                self.settings_by_config(self, options.config)

        if options.pta_cmd == 'priority':
            if options.priority_mode is not None:
                self.priorities_by_mode(self, options.priority_mode)

        # Tracing modified values after applying config
        for k in self.g_settings.__dict__.keys():
            if k not in 'config priority_mode':
                config_value = self.g_settings.__dict__[k]
                default_value = defaults.__dict__[k]
                if config_value != default_value:
                    self.print_if_verbose("%-30s %8s => %8s" % (k, default_value, config_value))

        # Applying user options on top of current settings
        for k in options.__dict__.keys():
            if k not in 'config priority_mode':
                if '--' + k in user_args:
                    user_value = options.__dict__[k]
                    config_value = self.g_settings.__dict__[k]
                    if user_value != default_value:
                        if config_value != user_value:
                            self.print_if_verbose("%-30s %8s -> %8s" % (k, config_value, user_value))
                            self.g_settings.__dict__[k] = user_value

        if options.pta_cmd == 'state':
            self.g_settings.state = options.state
        # Applying user 'settings' options on top of current settings

    def pta_bytes(self):
        header = []
        payload = list()
        nb_bytes = 4
        cmd_id = 0
        # self.print_if_verbose("PTA command: %s" % self.g_settings.pta_cmd)
        if self.g_settings.pta_cmd == 'settings':
            cmd_id = 0x002b
            for item in self.settings_parameters:
                _name, _type, _bytes, _choices, _default, _help = item
                item_value = self.g_settings.__dict__[_name]
                if _name != 'config':
                    if str(item_value).isnumeric():
                        int_value = int(item_value)
                    else:
                        int_value = int(_choices[item_value])
                    if _bytes == 1:
                        payload.append(str.format(r"\x%02x" % (int_value & 0x00FF)))
                    if _bytes == 2:
                        payload.append(str.format(r"\x%02x" % (int_value & 0x00FF)))
                        payload.append(str.format(r"\x%02x" % int((int_value & 0xFF00) >> 8)))
                    self.print_if_verbose(str.format("%-30s %-10s " % (_name, item_value)), end='')
                    self.print_if_verbose(''.join(payload[(nb_bytes-4):]))
                    nb_bytes += _bytes
        if self.g_settings.pta_cmd == 'priority':
            cmd_id = 0x002c
            bit_count = 0
            current_value = 0
            left_shift = 0
            for item in self.priority_parameters:
                _name, _type, _bytes, _choices, _default, _help = item
                item_value = self.g_settings.__dict__[_name]
                if _name != 'priority_mode':
                    if str(item_value).isnumeric():
                        int_value = int(item_value)
                    else:
                        int_value = int(_choices[item_value])
                    item_bytes, item_bits = str(_bytes).split(".")
                    current_value = current_value + (int_value << left_shift)
                    left_shift = left_shift + 8*int(item_bytes) + int(item_bits)
                    bit_count = left_shift
                    self.print_if_verbose(str.format("%-30s %-10s\n" % (_name, item_value)), end='')
            if bit_count != 32:
                print("There is an error in your priority bits definition, the total number of bits should be 32, and it's " + str(bit_count) + "!")
            nb_bytes += 4
            payload.append(str.format(r"\x%02x" % ((current_value & 0x000000FF) >> 0)))
            payload.append(str.format(r"\x%02x" % ((current_value & 0x0000FF00) >> 8)))
            payload.append(str.format(r"\x%02x" % ((current_value & 0x00FF0000) >> 16)))
            payload.append(str.format(r"\x%02x" % ((current_value & 0xFF000000) >> 24)))
            self.print_if_verbose(''.join(payload[(nb_bytes - 4):]))
        if self.g_settings.pta_cmd == 'state':
            cmd_id = 0x002d
            for item in self.state_parameters:
                _name, _type, _bytes, _choices, _default, _help = item
                item_value = self.g_settings.__dict__[_name]
                if str(item_value).isnumeric():
                    int_value = int(item_value)
                else:
                    int_value = int(_choices[item_value])
                payload.append(str.format(r"\x%02x" % ((int_value & 0x000000FF) >> 0)))
                payload.append(str.format(r"\x%02x" % ((int_value & 0x0000FF00) >> 8)))
                payload.append(str.format(r"\x%02x" % ((int_value & 0x00FF0000) >> 16)))
                payload.append(str.format(r"\x%02x" % ((int_value & 0xFF000000) >> 24)))
                self.print_if_verbose(str.format("%-30s %-10s " % (_name, item_value)), end='')
                self.print_if_verbose(''.join(payload[(nb_bytes-4):]))
                nb_bytes += _bytes
        header.append(str.format(r"\x%02x" % int(nb_bytes & 0x00FF)))
        header.append(str.format(r"\x%02x" % int(nb_bytes & 0xFF00)))
        header.append(str.format(r"\x%02x" % int(cmd_id & 0x00FF)))
        header.append(str.format(r"\x%02x" % int(cmd_id & 0xFF00)))
        data_bytes = r''.join(header + payload)
        return data_bytes


def command_line_main():
    
    
    if 'verbose' in sys.argv:
        mode = 'verbose'
        sys.argv.remove('verbose')
    else:
        mode = 'quiet'
    sys.exit(WfxPtaData(mode).data())


def command_line_test():
    pta = WfxPtaData()
    pta.mode = 'verbose'
    pta.set_args('settings --config 3w_example --request_signal_active_level low --first_slot_time 123'); print(pta.data())
    pta.mode = 'quiet'
    pta.set_args('settings --pta_mode 1w_coex_master'); print(pta.data())
    pta.set_args('settings --pta_mode 2w'); print(pta.data())
    pta.set_args('settings --pta_mode 3w'); print(pta.data())
    pta.set_args('settings --pta_mode 4w'); print(pta.data())
    pta.set_args('settings --request_signal_active_level low'); print(pta.data())
    pta.set_args('settings --priority_signal_active_level low'); print(pta.data())
    pta.set_args('settings --freq_signal_active_level low'); print(pta.data())
    pta.set_args('settings --grant_signal_active_level high'); print(pta.data())
    pta.set_args('settings --coex_type generic'); print(pta.data())
    pta.set_args('settings --coex_type ble'); print(pta.data())
    pta.set_args('settings --default_grant_state no_grant'); print(pta.data())
    pta.set_args('settings --simultaneous_rx_accesses true'); print(pta.data())
    pta.set_args('settings --priority_sampling_time 3'); print(pta.data())
    pta.set_args('settings --tx_rx_sampling_time 4'); print(pta.data())
    pta.set_args('settings --freq_sampling_time 5'); print(pta.data())
    pta.set_args('settings --grant_valid_time 6'); print(pta.data())
    pta.set_args('settings --fem_control_time 7'); print(pta.data())
    pta.set_args('settings --first_slot_time 8'); print(pta.data())
    pta.set_args('settings --periodic_tx_rx_sampling_time 9'); print(pta.data())
    pta.set_args('settings --coex_quota 1000'); print(pta.data())
    pta.set_args('settings --wlan_quota 1234'); print(pta.data())
    pta.set_args('state --state off'); print(pta.data())
    pta.set_args('state --state on'); print(pta.data())
    pta.set_args('priority --priority_mode coex_maximized'); print(pta.data())
    pta.set_args('priority --priority_mode coex_high'); print(pta.data())
    pta.set_args('priority --priority_mode balanced'); print(pta.data())
    pta.set_args('priority --priority_mode wlan_high'); print(pta.data())
    pta.set_args('priority --priority_mode wlan_maximized'); print(pta.data())
    pta.set_args('priority --coex_prio_low 7'); print(pta.data())
    pta.set_args('priority --coex_prio_high 7'); print(pta.data())
    pta.set_args('priority --grant_coex 1'); print(pta.data())
    pta.set_args('priority --grant_wlan 1'); print(pta.data())
    pta.set_args('priority --protect_coex 1'); print(pta.data())
    pta.set_args('priority --protect_wlan_tx 1'); print(pta.data())
    pta.set_args('priority --protect_wlan_rx 1'); print(pta.data())
    return 0


if __name__ == '__main__':
    if len(sys.argv) > 1:
        sys.exit(command_line_main())
    else:
        sys.exit(command_line_test())
